//! This module holds the core bare request types

use crate::messages::common::*;
use crate::protocol::*;
use katcp_derive::KatcpMessage;

#[derive(KatcpMessage, Debug, PartialEq, Eq)]
/// Requesting a Halt should trigger a software halt
/// It is expected to close the connection and put the
/// software and hardware into a state where it is safe to power down. The reply message should be sent just
/// before the halt occurs
pub enum Halt {
    Inform {},
    Request {},
    Reply {
        ret_code: RetCode,
        message: Option<String>,
    },
}

#[derive(KatcpMessage, Debug, PartialEq, Eq)]
pub enum Help {
    /// Although the description is not intended to be machine readable, the preferred convention for describing
    /// the parameters and return values is to use a syntax like that seen on the right-hand side of a BNF produc-
    /// tion (as commonly seen in the usage strings of UNIX command-line utilities and the synopsis sections
    /// of man pages). Brackets ([]) surround optional arguments, vertical bars (|) separate choices, and ellipses
    /// (...) can be repeated.
    Inform { name: String, description: String },
    /// Before sending a reply, the help request will send a number of #help inform messages. If no name
    /// parameter is sent the help request will return one inform message for each request available on the device.
    /// If a name parameter is specified, only an inform message for that request will be sent. On success the
    /// first reply parameter after the status code will contain the number of help inform messages generated by
    /// this request. If the name parameter does not correspond to a request on the device, a reply with a failure
    /// code and message should be sent
    Request { name: Option<String> },
    Reply {
        ret_code: RetCode,
        message: Option<String>,
    },
}

#[derive(KatcpMessage, Debug, PartialEq, Eq)]
/// Requesting a restart should trigger a software reset. It is expected to close the connection, reload the
/// software and begin execution again, preferably without changing the hardware configuration (if possible).
/// It would end with the device being ready to accept new connections again. The reply should be sent before
/// the connection to the current client is closed.
pub enum Restart {
    Inform {},
    Request {},
    Reply { ret_code: RetCode },
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_halt() {
        let halt_request = Halt::Request {};
        let halt_reply = Halt::Reply {
            ret_code: RetCode::Ok,
            message: None,
        };
        let request_payload = halt_request.into_message(None).unwrap().to_string();
        let reply_payload = halt_reply.into_message(None).unwrap().to_string();
        println!("{}", reply_payload);
        panic!()
    }
}
