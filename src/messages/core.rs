//! The requests and informs defined in this section deal with connecting to a device, halting it or restarting it
//! and querying it for some basic information about itself. KATCP devices are required to implement all of the
//! messages in this section.

use katcp_derive::KatcpMessage;

use crate::prelude::*;

#[derive(Debug, PartialEq, Eq, Clone)]
/// Requesting a Halt should trigger a software halt
/// It is expected to close the connection and put the
/// software and hardware into a state where it is safe to power down. The reply message should be sent just
/// before the halt occurs
pub enum Halt {
    Request,
    Reply {
        ret_code: RetCode,
        message: Option<String>,
    },
}

// We have to do a manual implementation here because katcp chose to make their argument grammar not context free
impl TryFrom<Message> for Halt {
    type Error = KatcpError;
    fn try_from(message: Message) -> Result<Self, Self::Error> {
        if message.name != "halt" {
            return Err(KatcpError::IncorrectType);
        }
        match message.kind {
            MessageKind::Request => Ok(Halt::Request),
            MessageKind::Reply => {
                let ret_code = RetCode::from_argument(
                    message
                        .arguments
                        .get(0)
                        .ok_or(KatcpError::MissingArgument)?,
                )?;
                let message = if !matches!(ret_code, RetCode::Ok) {
                    Some(String::from_argument(
                        message
                            .arguments
                            .get(1)
                            .ok_or(KatcpError::MissingArgument)?,
                    )?)
                } else {
                    None
                };
                Ok(Halt::Reply { ret_code, message })
            }
            MessageKind::Inform => unimplemented!(),
        }
    }
}

impl KatcpMessage for Halt {
    fn to_message(&self, id: Option<u32>) -> MessageResult {
        // Safety: No args, no safety concerns
        match self {
            Halt::Request => Ok(unsafe {
                Message::new_unchecked(MessageKind::Request, "halt", id, Vec::<String>::new())
            }),
            Halt::Reply { ret_code, message } => Ok(if matches!(ret_code, RetCode::Ok) {
                unsafe {
                    Message::new_unchecked(MessageKind::Reply, "halt", id, vec![
                        ret_code.to_argument()
                    ])
                }
            } else {
                // Safety: message.to_argument() escapes, so we're good there
                unsafe {
                    Message::new_unchecked(MessageKind::Reply, "halt", id, vec![
                        ret_code.to_argument(),
                        message.to_argument(),
                    ])
                }
            }),
        }
    }
}

impl TryFrom<&str> for Halt {
    type Error = KatcpError;
    fn try_from(s: &str) -> Result<Self, Self::Error> {
        let message: Message = s.try_into()?;
        message.try_into()
    }
}

#[derive(KatcpMessage, Debug, PartialEq, Eq)]
pub enum Help {
    /// Although the description is not intended to be machine readable, the preferred convention for describing
    /// the parameters and return values is to use a syntax like that seen on the right-hand side of a BNF produc-
    /// tion (as commonly seen in the usage strings of UNIX command-line utilities and the synopsis sections
    /// of man pages). Brackets ([]) surround optional arguments, vertical bars (|) separate choices, and ellipses
    /// (...) can be repeated.
    Inform { name: String, description: String },
    /// Before sending a reply, the help request will send a number of #help inform messages. If no name
    /// parameter is sent the help request will return one inform message for each request available on the device.
    /// If a name parameter is specified, only an inform message for that request will be sent. On success the
    /// first reply parameter after the status code will contain the number of help inform messages generated by
    /// this request. If the name parameter does not correspond to a request on the device, a reply with a failure
    /// code and message should be sent
    Request { name: Option<String> },
    /// In the case that `ret_code` here is [`RetCode::Ok`], the `message` will contain the number of help message
    /// informs that were sent. This makes the argument grammar non context free, so we'll leave that sum type implementation
    /// up to the client/server implementer
    Reply {
        ret_code: RetCode,
        message: Option<String>,
    },
}

#[derive(Debug, PartialEq, Eq)]
/// Requesting a restart should trigger a software reset. It is expected to close the connection, reload the
/// software and begin execution again, preferably without changing the hardware configuration (if possible).
/// It would end with the device being ready to accept new connections again. The reply should be sent before
/// the connection to the current client is closed.
pub enum Restart {
    Request,
    Reply {
        ret_code: RetCode,
        message: Option<String>,
    },
}

// We have to do a manual implementation here because katcp chose to make their argument grammar not context free
impl TryFrom<Message> for Restart {
    type Error = KatcpError;
    fn try_from(message: Message) -> Result<Self, Self::Error> {
        if message.name != "restart" {
            return Err(KatcpError::IncorrectType);
        }
        match message.kind {
            MessageKind::Request => Ok(Restart::Request),
            MessageKind::Reply => {
                let ret_code = RetCode::from_argument(
                    message
                        .arguments
                        .get(0)
                        .ok_or(KatcpError::MissingArgument)?,
                )?;
                let message = if !matches!(ret_code, RetCode::Ok) {
                    Some(String::from_argument(
                        message
                            .arguments
                            .get(1)
                            .ok_or(KatcpError::MissingArgument)?,
                    )?)
                } else {
                    None
                };
                Ok(Restart::Reply { ret_code, message })
            }
            MessageKind::Inform => unimplemented!(),
        }
    }
}

impl KatcpMessage for Restart {
    fn to_message(&self, id: Option<u32>) -> MessageResult {
        // Safety: No args, no safety concerns
        match self {
            Restart::Request => Ok(unsafe {
                Message::new_unchecked(MessageKind::Request, "restart", id, Vec::<String>::new())
            }),
            Restart::Reply { ret_code, message } => Ok(if matches!(ret_code, RetCode::Ok) {
                unsafe {
                    Message::new_unchecked(MessageKind::Reply, "restart", id, vec![
                        ret_code.to_argument()
                    ])
                }
            } else {
                // Safety: message.to_argument() escapes, so we're good there
                unsafe {
                    Message::new_unchecked(MessageKind::Reply, "restart", id, vec![
                        ret_code.to_argument(),
                        message.to_argument(),
                    ])
                }
            }),
        }
    }
}

impl TryFrom<&str> for Restart {
    type Error = KatcpError;
    fn try_from(s: &str) -> Result<Self, Self::Error> {
        let message: Message = s.try_into()?;
        message.try_into()
    }
}

#[derive(KatcpMessage, Debug, PartialEq, Eq)]
/// Requesting a watchdog may be sent by the client occasionally to check that the connection to the
/// device is still active. The device should respond with a success reply if it receives the watchdog request
pub enum Watchdog {
    Request {},
    Reply { ret_code: RetCode },
}

#[derive(KatcpMessage, Debug, PartialEq, Eq)]
/// Before sending a reply the ?version-list command will send a
/// series of #version-list informs. The list of informs should include all of the roles and components
/// returned via #version-connect but may contain additional roles or components.
pub enum VersionList {
    Inform {
        /// the name of the role or component the version information applies to
        name: String,
        /// a string identifying the version of the component. Individual components may define the structure
        /// of this argument as they choose. In the absence of other information clients should treat it as
        /// an opaque string
        version: String,
        /// a unique identifier for a particular instance of a componen
        uuid: String,
    },
    Request {},
    Reply {
        ret_code: RetCode,
        num_informs: u32,
    },
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::messages::common::roundtrip_test;

    #[test]
    fn test_halt() {
        roundtrip_test(Halt::Request);
        roundtrip_test(Halt::Reply {
            ret_code: RetCode::Invalid,
            message: Some("You messed up".to_owned()),
        });
        roundtrip_test(Halt::Reply {
            ret_code: RetCode::Ok,
            message: None,
        });
    }

    #[test]
    fn test_help() {
        roundtrip_test(Help::Request { name: None });
        roundtrip_test(Help::Request {
            name: Some("my_special_message".to_owned()),
        });
    }

    #[test]
    fn test_restart() {
        roundtrip_test(Restart::Request);
        roundtrip_test(Restart::Reply {
            ret_code: RetCode::Invalid,
            message: Some("You messed up".to_owned()),
        });
        roundtrip_test(Restart::Reply {
            ret_code: RetCode::Ok,
            message: None,
        });
    }

    #[test]
    fn test_watchdog() {
        roundtrip_test(Watchdog::Request {});
        roundtrip_test(Watchdog::Reply {
            ret_code: RetCode::Ok,
        });
    }

    #[test]
    fn test_version_list() {
        roundtrip_test(VersionList::Request {});
        roundtrip_test(VersionList::Inform {
            name: "my-special-device".to_owned(),
            version: "0.1.2.3rev10".to_owned(),
            uuid: "asdb132b34j".to_owned(),
        });
        roundtrip_test(VersionList::Reply {
            ret_code: RetCode::Ok,
            num_informs: 300,
        })
    }
}
